<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mangrove</title>
    <link>http://mongodb.github.io/mongo-cxx-odm/</link>
    <description>Recent content on Mangrove</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://mongodb.github.io/mongo-cxx-odm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Basics</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/1-basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/1-basics/</guid>
      <description>

&lt;h3 id=&#34;chapter-1&#34;&gt;Chapter 1&lt;/h3&gt;

&lt;h1 id=&#34;basics&#34;&gt;Basics&lt;/h1&gt;

&lt;p&gt;Learn what &lt;strong&gt;Mangrove&lt;/strong&gt; is and how it can help you build C++ applications with MongoDB.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Models</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/2-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/2-models/</guid>
      <description>

&lt;h3 id=&#34;chapter-2&#34;&gt;Chapter 2&lt;/h3&gt;

&lt;h1 id=&#34;models&#34;&gt;Models&lt;/h1&gt;

&lt;p&gt;Learn how to make the most of Mangrove &lt;strong&gt;models&lt;/strong&gt;, which allow you to map C++ classes to MongoDB collections.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Queries</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/3-queries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/3-queries/</guid>
      <description>

&lt;h3 id=&#34;chapter-3&#34;&gt;Chapter 3&lt;/h3&gt;

&lt;h1 id=&#34;queries&#34;&gt;Queries&lt;/h1&gt;

&lt;p&gt;Learn about the rich &lt;strong&gt;query&lt;/strong&gt; system supported by Mangrove&amp;rsquo;s &lt;strong&gt;models&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The BSON Mapper</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/5-the-bson-mapper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/5-the-bson-mapper/</guid>
      <description>

&lt;h3 id=&#34;chapter-5&#34;&gt;Chapter 5&lt;/h3&gt;

&lt;h1 id=&#34;the-bson-mapper&#34;&gt;The BSON Mapper&lt;/h1&gt;

&lt;p&gt;Learn about the 
&lt;a target=&#34;_blank&#34; href=&#34;http://uscilab.github.io/cereal/&#34;&gt;Cereal &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
-powered &lt;strong&gt;BSON serializer&lt;/strong&gt; that makes Mangrove work, and how you can use it in your own applications.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Updates</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/4-updates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/4-updates/</guid>
      <description>

&lt;h3 id=&#34;chapter-4&#34;&gt;Chapter 4&lt;/h3&gt;

&lt;h1 id=&#34;updates&#34;&gt;Updates&lt;/h1&gt;

&lt;p&gt;Learn how to use Mangrove&amp;rsquo;s &lt;strong&gt;update&lt;/strong&gt; builder to perform advanced bulk updates.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/2-models/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/2-models/introduction/</guid>
      <description>

&lt;p&gt;A &lt;strong&gt;model&lt;/strong&gt; is the fundamental way you access data in MongoDB with Mangrove. Models lets you treat C++ classes as objects you can store in the database. When you make a class a model, it is given the semantics of a MongoDB collection, and has access to all of 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-odm/api/html/classmongo__odm_1_1model.html&#34;&gt;these static methods &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-model&#34;&gt;Creating a Model&lt;/h2&gt;

&lt;p&gt;You can turn any &lt;em&gt;default-constructible&lt;/em&gt; C++ class into a model by having it inherit publicly from the &lt;code&gt;mangrove::model&amp;lt;T&amp;gt;&lt;/code&gt; base class, where &lt;code&gt;T&lt;/code&gt; is type of the class you are making a model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Example of inheritance required for model
class Message : mangrove::model&amp;lt;Message&amp;gt; {
    bsoncxx::oid author_id;
    std::string content;
    std::chrono::system_clock::time_point time_sent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This inheritance gives the inheriting class access to the interface specified 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-odm/api/html/classmongo__odm_1_1model.html&#34;&gt;here &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
. The inheritance also gives you access to the &lt;code&gt;_id&lt;/code&gt; variable. Since every document stored in a MongoDB database contains an &lt;code&gt;_id&lt;/code&gt;, the model stores one automatically for you. By default this of type 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-driver/classbsoncxx_1_1oid.html&#34;&gt;&lt;code&gt;bsoncxx::oid&lt;/code&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
, but you can customize it. We&amp;rsquo;ll discuss how to do this in a &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/2-models/custom_id&#34;&gt;later section&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;specifying-fields-to-serialize&#34;&gt;Specifying Fields to Serialize&lt;/h2&gt;

&lt;p&gt;Before you can use a model, you must specify which of its fields you want to be included when an instance of a model is serialized and saved to the database. You can do this with the &lt;code&gt;MANGROVE_MAKE_KEYS_MODEL&lt;/code&gt; macro.&lt;/p&gt;

&lt;p&gt;This macro accepts the class you are registering as a model, as well as a variadic list of the fields you want to include, wrapped as name-value pairs (&lt;strong&gt;NVPs&lt;/strong&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Example of registering fields in model
class Message : mangrove::model&amp;lt;Message&amp;gt; {
    bsoncxx::oid author_id;
    std::string content;
    std::chrono::system_clock::time_point time_sent;
    int dont_include_me;

    MANGROVE_MAKE_KEYS_MODEL(Message,
                             MANGROVE_NVP(author_id),
                             MANGROVE_NVP(content),
                             MANGROVE_NVP(time_sent))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;MANGROVE_NVP&lt;/code&gt; macro specifies that you want its argument serialized in such a way that its &lt;strong&gt;name&lt;/strong&gt; or &lt;strong&gt;key&lt;/strong&gt; is the name of the variable. For example, in the above code sample, the resulting saved BSON document would look something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;576d7238e249391db3271e31&amp;quot;),
    &amp;quot;author_id&amp;quot; : ObjectId(&amp;quot;576d5145e2493917691144f1&amp;quot;),
    &amp;quot;content&amp;quot; : &amp;quot;Hey, did you see how cool Mangrove is?!&amp;quot;,
    &amp;quot;time_sent&amp;quot; : ISODate(&amp;quot;2016-07-01T14:42:06.018Z&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices info&#34; &gt;&lt;p&gt;While there is no limitation to the complexity of the classes you can turn into a model, there are limitations regarding which types are serializable and can be included in the &lt;code&gt;MANGROVE_MAKE_KEYS_MODEL&lt;/code&gt; macro. These limitations are discussed in the &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/2-models/allowed-types&#34;&gt;next section&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;If you don&amp;rsquo;t want the name of the field to be exactly the same as the name of your variable, you can use the macro &lt;code&gt;MANGROVE_CUSTOM_NVP&lt;/code&gt; to specify a custom name for the resulting BSON element of a particular field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Example of registering fields in model with custom names
class Message : mangrove::model&amp;lt;Message&amp;gt; {
    bsoncxx::oid author_id;
    std::string content;
    std::chrono::system_clock::time_point time_sent;
    int dont_include_me;

    MANGROVE_MAKE_KEYS_MODEL(Message,
                             MANGROVE_CUSTOM_NVP(&amp;quot;a_id&amp;quot;, author_id),
                             MANGROVE_CUSTOM_NVP(&amp;quot;c&amp;quot;, content),
                             MANGROVE_NVP(time_sent))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, the resulting BSON documents would now look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;576d7238e249391db3271e31&amp;quot;),
    &amp;quot;a_id&amp;quot; : ObjectId(&amp;quot;576d5145e2493917691144f1&amp;quot;),
    &amp;quot;c&amp;quot; : &amp;quot;Hey, did you see how cool Mangrove is?!&amp;quot;,
    &amp;quot;time_sent&amp;quot; : ISODate(&amp;quot;2016-07-01T14:42:06.018Z&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices tip&#34; &gt;&lt;p&gt;If you have extremely large collections and want to save some disk space and bandwidth, you can use custom NVPs to shorten the names of fields associated with large variable names to a single-letter.&lt;/p&gt;
&lt;/div&gt;


&lt;h3 id=&#34;public-vs-private-members&#34;&gt;Public vs. Private Members&lt;/h3&gt;

&lt;p&gt;In Mangrove, you can serialize both public and private class members. The only caveat with this is that you won&amp;rsquo;t be able to access private members in &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/3-queries&#34;&gt;queries&lt;/a&gt; or &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/4-updates&#34;&gt;updates&lt;/a&gt; that you build outside of the class. If you want to keep your models encapsulated, build all of the queries and updates you&amp;rsquo;ll be using inside your model&amp;rsquo;s member functions.&lt;/p&gt;

&lt;h2 id=&#34;linking-with-the-database&#34;&gt;Linking With the Database&lt;/h2&gt;

&lt;p&gt;The last step you must take before you can use a model is to register it with a MongoDB database. Mangrove itself doesn&amp;rsquo;t handle the connection to the database, that responsibility is held by the C++ Driver, which provides the &lt;code&gt;mongocxx::client&lt;/code&gt; class. You can learn more about that class in the C++ Driver&amp;rsquo;s 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-driver/classmongocxx_1_1client.html&#34;&gt;API Documentation &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;

&lt;p&gt;In the following example, we&amp;rsquo;ll use a connection to the database hosted at &lt;code&gt;localhost&lt;/code&gt; on port 27017.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;mongocxx/client.hpp&amp;gt;
#include &amp;lt;mongocxx/instance.hpp&amp;gt;

int main() {
    mongocxx::instance{};
    mongocxx::client 
        conn{mongocxx::uri{&amp;quot;mongodb://localhost:27017&amp;quot;};

    Message::setCollection(conn[&amp;quot;testdb&amp;quot;][&amp;quot;messages&amp;quot;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All models have a static function &lt;code&gt;setCollection()&lt;/code&gt; that lets you specify in which collection to save and retrieve instances of that particular model. It accepts a &lt;code&gt;mongocxx::collection&lt;/code&gt;, which is accessible via the &lt;code&gt;mongocxx::client&lt;/code&gt;. The code above sets &lt;code&gt;Message&lt;/code&gt;&amp;rsquo;s collection to the &lt;code&gt;&amp;quot;entries&amp;quot;&lt;/code&gt; collection in the &lt;code&gt;&amp;quot;my_blog&amp;quot;&lt;/code&gt; database hosted at &lt;code&gt;&amp;quot;mongodb://localhost:27017&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;The &lt;code&gt;mongocxx::client&lt;/code&gt; class is &lt;em&gt;not thread-safe&lt;/em&gt;. To get around this, the &lt;code&gt;mangrove::model&lt;/code&gt; class provides thread-local storage for the collection associated with a particular model. You can make your applications thread-safe by calling the model&amp;rsquo;s &lt;code&gt;setCollection()&lt;/code&gt; function on each thread with a collection from a new &lt;code&gt;mongocxx::client&lt;/code&gt;. You can read more about the C++ Driver&amp;rsquo;s thread safety
&lt;a target=&#34;_blank&#34; href=&#34;https://github.com/mongodb/mongo-cxx-driver/wiki/Library-Thread-Safety&#34;&gt;here &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;
&lt;/div&gt;


&lt;h2 id=&#34;active-record-manipulation&#34;&gt;Active Record Manipulation&lt;/h2&gt;

&lt;p&gt;The simplest way to add, modify, and remove objects of a particular model is through the 
&lt;a target=&#34;_blank&#34; href=&#34;https://en.wikipedia.org/wiki/Active_record_pattern&#34;&gt;active record pattern &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
. When you create an instance of a model class, that instance can be saved to the database with its &lt;code&gt;save()&lt;/code&gt; method, and it can also be removed from the database with its &lt;code&gt;remove()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;mongocxx/client.hpp&amp;gt;
#include &amp;lt;mongocxx/instance.hpp&amp;gt;

int main() {
    mongocxx::instance{};
    mongocxx::client 
        conn{mongocxx::uri{&amp;quot;mongodb://localhost:27017&amp;quot;};

    Message::setCollection(conn[&amp;quot;testdb&amp;quot;][&amp;quot;messages&amp;quot;]);

    Message msg{bsoncxx::oid(&amp;quot;576d5145e2493917691144f1&amp;quot;),
                &amp;quot;Hey, did you see how cool Mangrove is?!&amp;quot;.
                std::chrono::system_clock::now(), 42};

    // Inserts the message to the database.
    msg.save();

    // Updates the message in the database.
    msg.content = &amp;quot;I edited my message!&amp;quot;;
    msg.save();

    // Removes the message from the database.
    msg.remove();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This might not seem very interesting since we&amp;rsquo;ve only used the active record model on objects have been created within the program. However, the &lt;code&gt;save()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; methods are also available with model objects that get returned from queries. We&amp;rsquo;ll go more in depth about queries in Mangrove in the &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/3-queries&#34;&gt;next chapter&lt;/a&gt;, but the following example demonstrates how we can use the active record model to delete every message from a particular user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(auto msg : Message::find(MANGROVE_KEY(Message::author_id) == bsoncxx::oid(&amp;quot;576d5145e2493917691144f1&amp;quot;))) {
    msg.remove();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;While the above code works, a more efficient way of achieving the same result is through a bulk delete with the model&amp;rsquo;s &lt;code&gt;deleteMany()&lt;/code&gt; method.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/3-queries/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/3-queries/introduction/</guid>
      <description>

&lt;p&gt;Mangrove provides a &lt;strong&gt;query builder&lt;/strong&gt; with static type-checking for constructing MongoDB queries.
This allows you to compare documents using familiar C++ syntax using operators such as &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.
These query objects are automatically converted to BSON, and can be passed either to the Mangrove Model&amp;rsquo;s &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;find_one&lt;/code&gt; methods, to the Mangrove collection wrapper, or to the query methods in the Mongo C++ Driver.&lt;/p&gt;

&lt;p&gt;The query builder helps you avoid JSON syntax errors, such as forgetting a closing curly brace, and will catch other errors at compile time &amp;mdash; so you don&amp;rsquo;t have to wait until your queries return errors in production (or silently return incorrect results!) to catch mistakes.&lt;/p&gt;

&lt;p&gt;Mangrove currently supports all the 
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/v3.2/reference/operator/query/&#34;&gt;query operators &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 as of MongoDB 3.2,
except for &lt;code&gt;$type&lt;/code&gt;, &lt;code&gt;$where&lt;/code&gt;, and geospatial queries. If you need to use these operators, create the BSON for the query as you 
&lt;a target=&#34;_blank&#34; href=&#34;https://github.com/mongodb/mongo-cxx-driver/wiki/Handling-BSON-in-the-new-driver&#34;&gt;normally would &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 using the MongoDB C++ driver.&lt;/p&gt;

&lt;p&gt;Consider the following class that represents a user of some website:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class User : public mangrove::model&amp;lt;User&amp;gt; {
public:
    std::string username;
    std::int32_t age;

    MANGROVE_MAKE_KEYS_MODEL(User, MANGROVE_NVP(username), MANGROVE_NVP(age));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the users in the database that are over 21 years of age, one would use the following query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$gte: 21} }
auto results = User::find(MANGROVE_KEY(User::age) &amp;gt;= 21);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;collection&lt;/code&gt; is a &lt;code&gt;mongocxx::collection&lt;/code&gt; object from the C++ Driver.
The different parts of this code will be explained in more detail below,
but note the &lt;code&gt;MANGROVE_KEY&lt;/code&gt; macro that is used to refer to individual fields in the document.
Then, Mangrove uses 
&lt;a target=&#34;_blank&#34; href=&#34;http://en.cppreference.com/w/cpp/language/operators&#34;&gt;operator overloading &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 to allow the field to be compared to &lt;code&gt;21&lt;/code&gt; with the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.
This constructs a query object, which is implicitly cast to a BSON value when passed into &lt;code&gt;mongocxx::collection::find()&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;The query objects should only be used as &lt;em&gt;temporary objects&lt;/em&gt; &amp;mdash; that is, constructed and passed directly into another function, such as &lt;code&gt;find()&lt;/code&gt;.
Attempting to store these queries in a variable and use them later may produce undefined results.
This is because the query expressions store their arguments by reference to avoid putting too much data on the stack.&lt;/p&gt;
&lt;/div&gt;


&lt;h2 id=&#34;specifying-fields&#34;&gt;Specifying fields&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ve already seen one way of referring to fields, the &lt;code&gt;MANGROVE_KEY&lt;/code&gt; macro.
This macro takes a class member specified as &lt;code&gt;Base::member&lt;/code&gt;, and creates a &amp;ldquo;field object&amp;rdquo; that can be used in queries.&lt;/p&gt;

&lt;h4 id=&#34;referring-to-embedded-fields&#34;&gt;Referring to embedded fields&lt;/h4&gt;

&lt;p&gt;Referring to fields in embedded objects is a bit different.
Let&amp;rsquo;s say we wanted to add an Address class to our User:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Address {
public:
    std::string street;
    std::string city;
    std::string state;
    std::string zip;  

    MANGROVE_MAKE_KEYS(Address, MANGROVE_NVP(street), MANGROVE_NVP(city),
                                MANGROVE_NVP(state), MANGROVE_NVP(zip));
};

class User : public mangrove::model&amp;lt;User&amp;gt; {
public:
    std::string username;
    std::int32_t age;
    Address addr;

    MANGROVE_MAKE_KEYS_MODEL(User, MANGROVE_NVP(username), MANGROVE_NVP(age), MANGROVE_NVP(addr));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can query for users using their address using the &lt;code&gt;MANGROVE_CHILD&lt;/code&gt; macro:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { &amp;quot;addr.zip&amp;quot;: &amp;quot;21211&amp;quot; }
auto results = User::find(MANGROVE_CHILD(User, addr, zip) == &amp;quot;21211&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;MANGROVE_CHILD&lt;/code&gt; takes a base class, and then the names of each successive nested field.&lt;/p&gt;

&lt;div class=&#34;notices info&#34; &gt;&lt;p&gt;Mangrove can support as many levels of nesting as is allowed in the
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/limits/#Nested-Depth-for-BSON-Documents&#34;&gt;BSON specification &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Another way to refer to children is to link field objects using the &lt;code&gt;-&amp;gt;*&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { &amp;quot;addr.zip&amp;quot;: &amp;quot;21211&amp;quot; }
auto results = User::find(MANGROVE_KEY(User::addr) -&amp;gt;* MANGROVE_KEY(Address::zip) == &amp;quot;21211&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;referring-to-array-elements&#34;&gt;Referring to array elements&lt;/h4&gt;

&lt;p&gt;Referring to specific array elements in queries is the same as in any C++ expression &amp;mdash;
one can simply user the square brackets &lt;code&gt;[]&lt;/code&gt; to specify a certain index.
For instance, the following query finds users whose 10th score in some game is higher than 1000:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { &amp;quot;scores.9&amp;quot;: {$gt: 1000} }
// (note that arrays are 0-indexed)
auto results = User::find(MANGROVE_KEY(User::scores)[9] &amp;gt; 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;type-checking&#34;&gt;Type checking&lt;/h2&gt;

&lt;p&gt;Mangrove provides type checking on queries, so that comparing fields and values with mismatched types,
or using array operators on non-array fields, results in compile-time errors.&lt;/p&gt;

&lt;p&gt;For instance, the following query will fail at compile time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$gte: &amp;quot;21&amp;quot;} }
auto results = User::find(MANGROVE_KEY(User::age) &amp;gt;= &amp;quot;21&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the mongo shell, for instance, such a query would be just fine,
but would have done a lexicographic comparison between the &lt;code&gt;age&lt;/code&gt; field and the string &lt;code&gt;&amp;quot;21&amp;quot;&lt;/code&gt;.
This is definitely not what we want, and may only have been discovered later, in production.&lt;/p&gt;

&lt;p&gt;Similarly, the query&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$all: [15, 17, 19]} }
auto results = User::find(MANGROVE_KEY(User::age).all(std::vector&amp;lt;int&amp;gt;{15, 17, 19}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;does not make sense because &lt;code&gt;User::age&lt;/code&gt; is not an array, and will cause a syntax error accordingly.&lt;/p&gt;

&lt;h2 id=&#34;combining-queries&#34;&gt;Combining queries&lt;/h2&gt;

&lt;p&gt;There are several ways to combine different conditions into one query in Mangrove.
The simplest one is the comma operator &amp;mdash; conditions can be appended one after the other, separated by a comma.
This is the same as having comma-separated fields in a BSON query; it has the effect of a logical AND
on the various conditions.&lt;/p&gt;

&lt;p&gt;The following query filters by users&amp;rsquo; age as well as address:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$gt: 65}, &amp;quot;addr.state&amp;quot;: &amp;quot;NY&amp;quot; }
auto results = User::find((MANGROVE_KEY(User::age) &amp;gt; 65, MANGROVE_CHILD(User, addr, state) == &amp;quot;NY&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;Note that the query expression is inside another set of parentheses.
This is to ensure that the different conditions are combined as one query,
instead of passed to &lt;code&gt;find()&lt;/code&gt; as different arguments.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Queries can also be combined using boolean operators:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { $and: [
//          {$or: [{age: {$gt: 65}}, {age: {$lt: 5}}]},
//          {&amp;quot;addr.state&amp;quot;: &amp;quot;NY&amp;quot;}
//        ] }
auto results = User::find((MANGROVE_KEY(User::age) &amp;gt; 65 || MANGROVE_KEY(User::age) &amp;lt; 5) &amp;amp;&amp;amp; MANGROVE_CHILD(User, addr, state) == &amp;quot;NY&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;notices tip&#34; &gt;&lt;p&gt;Using boolean operators also allows you to use the same field in several conditions.
Above, &lt;code&gt;User::age&lt;/code&gt; was compared twice.
This is not supported in MongoDB when combining queries with commas.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/4-updates/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/4-updates/introduction/</guid>
      <description>&lt;p&gt;Mangrove&amp;rsquo;s expression builder also provides the ability to construct &lt;strong&gt;update&lt;/strong&gt; expressions.
The syntax is pretty much the same as for query expressions &amp;mdash; you refer to fields
using &lt;code&gt;MANGROVE_KEY&lt;/code&gt; and the other macros, and update them using
C++ operators such as &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt;. Member functions are provided for operators which don&amp;rsquo;t have
a built-in C++ operator analog, such as the &lt;code&gt;$addToSet&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;The following is an example of a bulk update which would edit sales tax info for users who live in
New York:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// In the Mongo shell, this would be:
// db.collection.updateMany({&amp;quot;addr.state&amp;quot;: &amp;quot;NY&amp;quot;}, {$set: {sales_tax: 0.10}});
auto res = User::update_many(MANGROVE_CHILD(User, addr, state) == &amp;quot;NY&amp;quot;, MANGROVE_KEY(User::sales_tax) = 0.10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that a query, as seen in 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-odm/3-queries/&#34;&gt;chapter 3 &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
,
is given as the first argument, and an update is given as the second.&lt;/p&gt;

&lt;p&gt;The next section contains a reference of the available update operators.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Operators</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/3-queries/operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/3-queries/operators/</guid>
      <description>

&lt;p&gt;The following is a list of the available &lt;strong&gt;query operators&lt;/strong&gt; for the Mangrove query builder.
This page follows the structure of the

&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/&#34;&gt;MongoDB query operator documentation &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;

&lt;h3 id=&#34;comparison-operators&#34;&gt;Comparison Operators&lt;/h3&gt;

&lt;p&gt;The following operators can be expressed using built-in C++ operators such as &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.
They work on any field type, and the right-hand value must be the same type as the field.
Free functions are also provided in the &lt;code&gt;mangrove&lt;/code&gt; namespace that can be used in lieu of the overloaded
operators.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/eq/&#34;&gt;$eq &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$eq: 21} }
auto results = User::find(MANGROVE_KEY(User::age) == 21);
auto results = User::find(mangrove::eq(MANGROVE_KEY(User::age), 21));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/gt/&#34;&gt;$gt &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$gt: 21} }
auto results = User::find(MANGROVE_KEY(User::age) &amp;gt; 21);
auto results = User::find(mangrove::gt(MANGROVE_KEY(User::age), 21));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/gte/&#34;&gt;$gte &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$gte: 21} }
auto results = User::find(MANGROVE_KEY(User::age) &amp;gt;= 21);
auto results = User::find(mangrove::gte(MANGROVE_KEY(User::age), 21));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/lt/&#34;&gt;$lt &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$lt: 21} }
auto results = User::find(MANGROVE_KEY(User::age) &amp;lt; 21);
auto results = User::find(mangrove::lt(MANGROVE_KEY(User::age), 21));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/lte/&#34;&gt;$lte &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$lte: 21} }
auto results = User::find(MANGROVE_KEY(User::age) &amp;lt;= 21);
auto results = User::find(mangrove::lte(MANGROVE_KEY(User::age), 21));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/ne/&#34;&gt;$ne &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$ne: 21} }
auto results = User::find(MANGROVE_KEY(User::age) != 21);
auto results = User::find(mangrove::ne(MANGROVE_KEY(User::age), 21));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following operators are provided as member functions of the fields which are returned from the
&lt;code&gt;MANGROVE_KEY&lt;/code&gt; and other macros.
If the field is a scalar, then the given right hand side must be an array containing the same type.
If the field is an array, then the given right hand side must be a similar array, containing the same type.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/in/&#34;&gt;$in &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$in: [16, 18, 21]} }
int ages = std::vector&amp;lt;int&amp;gt;{16, 18, 21}
auto results = User::find(MANGROVE_KEY(User::age).in(ages));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/nin/&#34;&gt;$nin &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$nin: [16, 18, 21]} }
int ages = std::vector&amp;lt;int&amp;gt;{16, 18, 21}
auto results = User::find(MANGROVE_KEY(User::age).nin(ages));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;logical-operators&#34;&gt;Logical Operators&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;$or&lt;/code&gt; and &lt;code&gt;$and&lt;/code&gt; operators can be used to chain different sub-queries together.
When using both at once, the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; follow their usual C++ precedence rules.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/or/&#34;&gt;$or &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { $or: [ {age: {$gt: 65}}, {age: {$lt: 5}} ] }
auto results = User::find((MANGROVE_KEY(User::age) &amp;gt; 65 || MANGROVE_KEY(User::age) &amp;lt; 5));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/and/&#34;&gt;$and &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { $and: [ {age: {$gt: 65}}, {age: {$lt: 5}} ] }
auto results = User::find((MANGROVE_KEY(User::age) &amp;gt; 65 &amp;amp;&amp;amp; MANGROVE_KEY(User::age) &amp;lt; 5));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/not/&#34;&gt;$not &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$not&lt;/code&gt; operator is applied to individual comparisons
(as opposed to boolean expressions using the above operators).
The C++ &lt;code&gt;!&lt;/code&gt; operator is used for this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; // { age: {$not: {$lt: 21}} }
 auto results = User::find(!(MANGROVE_KEY(User::age) &amp;lt; 21));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/nor/&#34;&gt;$nor &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$nor&lt;/code&gt; operator behaves similarly to the &lt;code&gt;$and&lt;/code&gt; and &lt;code&gt;$or&lt;/code&gt; operators,
except that there is no built-in C++ &lt;code&gt;NOR&lt;/code&gt; operator. As such, it is provided as a free function that takes
a list of query expressions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; // { $nor: [ {age: {$gt: 65}}, {age: {$lt: 5}} ] }
 auto results = User::find(mangrove::nor(MANGROVE_KEY(User::age) &amp;gt; 65, MANGROVE_KEY(User::age) &amp;lt; 5));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;element-operators&#34;&gt;Element Operators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/exists/&#34;&gt;$exists &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$exists&lt;/code&gt; operator is provided as a member function on fields that takes a boolean
argument. It is only enabled for &lt;strong&gt;optional&lt;/strong&gt; fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$exists: true} }
auto results = User::find(MANGROVE_KEY(User::age).exists(true));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/type/&#34;&gt;$type &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;
operator is not currently available in the Mangrove query builder,
since to work with serialization,
the types of fields must correspond to the type defined in the C++ class.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;evaluation-operators&#34;&gt;Evaluation Operators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/mod/&#34;&gt;$mod &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on fields,
and accepts two parameters: a divisor and a remainder.
It is only enabled for fields with numeric types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { age: {$mod: {$divisor: 10, $remainder: 3}} }
auto results = User::find(MANGROVE_KEY(User::age).mod(10, 3));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/regex/&#34;&gt;$regex &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on fields,
and accepts two parameters: a regex string and an options string.
It is only enabled for string fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Match users who live on a numbered street, like &amp;quot;14th st.&amp;quot;:
// { &amp;quot;addr.street&amp;quot;: {$regex: &amp;quot;\d+th st\.?&amp;quot;, $options: &amp;quot;i&amp;quot;} }
auto results = User::find(MANGROVE_CHILD(User, addr, street).regex(&amp;quot;\\d+th st\\.?&amp;quot;, &amp;quot;i&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/text/&#34;&gt;$text &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator performs a search on a text index in the database.
It is provided as a free function that accepts a text query as a string,
as well as the optional &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;case_sensitive&lt;/code&gt;, and &lt;code&gt;diacritic_sensitive&lt;/code&gt; parameters
as per the MongoDB documentation.
These parameters can be passed in as &lt;code&gt;optional&lt;/code&gt; values,
or specified using &amp;ldquo;fluent&amp;rdquo; setter functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// {
//   $text:
//     {
//       $search: &amp;quot;boulevard&amp;quot;,
//       $language: &amp;quot;en&amp;quot;,
//       $caseSensitive: false,
//       $diacriticSensitive: false
//     }
// }
auto results = User::find(mangrove::text(&amp;quot;boulevard&amp;quot;).language(&amp;quot;en&amp;quot;)
                                                     .case_sensitive(false)
                                                     .diacritic_sensitive(false));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;There are
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/text/#restrictions&#34;&gt;restrictions &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 on the syntax of the &lt;code&gt;$text&lt;/code&gt; operator that Mangrove does not check.
Refer to the MongoDB documentation to make sure that the &lt;code&gt;$text&lt;/code&gt; operator is being used correctly.
Also, fields &lt;strong&gt;must&lt;/strong&gt; be text-indexed for the &lt;code&gt;$text&lt;/code&gt; operator to work on them.&lt;/p&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/where/&#34;&gt;$where &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Mangrove does not provide a &lt;code&gt;$where&lt;/code&gt; operator.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;geospational-operators&#34;&gt;Geospational Operators&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Mangrove does not currently support geospatial operators, although support is planned in the future, along with a dedicated GeoJSON C++ data type.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;array-operators&#34;&gt;Array Operators&lt;/h3&gt;

&lt;p&gt;For the following code samples, assume that a User has a field &lt;code&gt;scores&lt;/code&gt;, which contains an array of integers.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/all/&#34;&gt;$all &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on fields.
It accepts an array of values that are the same type as the elements of the field&amp;rsquo;s array.
This is only enabled for fields which are iterable (i.e. arrays).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { scores: {$all: [100, 500, 1000]} }
auto results = User::find(MANGROVE_KEY(User::scores).all(std::vector&amp;lt;int&amp;gt;{100, 500, 1000}));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/elemMatch/&#34;&gt;$elemMatch &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator accepts a query, and returns documents if the elements inside a field&amp;rsquo;s array match
the given queries. The queries can be constructed in Mangrove using the same syntax as top-level queries.&lt;/p&gt;

&lt;p&gt;For instance, if a User document contains a field &lt;code&gt;past_homes&lt;/code&gt;, which is an array of addresses,
one could query it like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Find users that have lived, at some point, in Maryland.
// { past_homes: {$elemMatch: {state: &amp;quot;MD&amp;quot;}} }
auto results = User::find(MANGROVE_KEY(User::past_homes).elem_match(MANGROVE_KEY(Address::state) == &amp;quot;MD&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;$elemMatch&lt;/code&gt; on scalar arrays is a bit tricky, since the scalars don&amp;rsquo;t have field names to refer to.
Instead, one uses the &lt;code&gt;MANGROVE_KEY_ELEM(...)&lt;/code&gt; macro to create a field object that refers to
the &lt;em&gt;elements&lt;/em&gt; of an array. (The equivalent for &lt;code&gt;MANGROVE_CHILD&lt;/code&gt; is &lt;code&gt;MANGROVE_CHILD_ELEM&lt;/code&gt;.)
One can also use &lt;code&gt;MANGROVE_KEY(...).element()&lt;/code&gt; and &lt;code&gt;MANGROVE_CHILD(...).element()&lt;/code&gt;, respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Find users with a score greater than 9000.
// { scores: {$elemMatch: {$gt: 9000}} }

// The following are equivalent:
auto results = User::find(MANGROVE_KEY(User::scores).elem_match(MANGROVE_KEY_ELEM(User::score) &amp;gt; 9000));
results = User::find(MANGROVE_KEY(User::scores).elem_match(MANGROVE_KEY(User::score).element() &amp;gt; 9000));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;When specifying conditions on the fields of documents in an array in the &lt;code&gt;$elemMatch&lt;/code&gt; operator,
the fields are referred to as top-level fields.
In the example above, the &lt;code&gt;state&lt;/code&gt; field is used as &lt;code&gt;MANGROVE_KEY(Adress::state)&lt;/code&gt;,
as opposed to &lt;code&gt;MANGROVE_CHILD(User, past_homes, state)&lt;/code&gt;.
This mirrors the syntax of MongoDB queries themselves.
The equivalent BSON would refer to the &lt;code&gt;state&lt;/code&gt; field simply as &lt;code&gt;state&lt;/code&gt;, not &lt;code&gt;&amp;quot;past_homes.state&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Mangrove does not check if you use &lt;code&gt;.element()&lt;/code&gt; or &lt;code&gt;MANGROVE_KEY_ELEM&lt;/code&gt; outside of &lt;code&gt;elem_match(...)&lt;/code&gt;.
This will cause a runtime error when the MongoDB server receives an invalid query.&lt;/p&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/size/&#34;&gt;$size &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on fields.
It accepts a single argument, which is the array size to check.
The operator is only enabled for fields which are iterable (i.e. arrays).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// { scores: {$size: 10} }
auto results = User::find(MANGROVE_KEY(User::scores).size(10));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bitwise-operators&#34;&gt;Bitwise Operators&lt;/h3&gt;

&lt;p&gt;The following operators query for documents using bit operations on fields.
Each operator has two versions: one that accepts a single &lt;em&gt;mask&lt;/em&gt;,
either as an integer or a BSON &lt;code&gt;b_binary&lt;/code&gt; type, and another that takes a variadic number of
bit &lt;em&gt;positions&lt;/em&gt; as unsigned integers.&lt;/p&gt;

&lt;p&gt;These operators are only enabled for integral or &lt;code&gt;b_binary&lt;/code&gt; types.&lt;/p&gt;

&lt;p&gt;For the following examples, assume that the User class has an integer field &lt;code&gt;bitvector&lt;/code&gt; that
represents a set of bits that we want to do bitwise operations on.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/bitsAllSet/&#34;&gt;$bitsAllSet &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// We want to compare the `bitvector` field with the value 0b00010101.
// The following two queries are equivalent:

// { scores: {$bitsAllSet: 21} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAllSet(21));
// { scores: {$bitsAllSet: [0, 2, 4]} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAllSet(0, 2, 4));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/bitsAnySet/&#34;&gt;$bitsAnySet &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// We want to compare the `bitvector` field with the value 0b00010101.
// The following two queries are equivalent:

// { scores: {$bitsAnySet: 21} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAnySet(21));
// { scores: {$bitsAnySet: [0, 2, 4]} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAnySet(0, 2, 4));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/bitsAllClear/&#34;&gt;$bitsAllClear &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// We want to compare the `bitvector` field with the value 0b00010101.
// The following two queries are equivalent:

// { scores: {$bitsAllClear: 21} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAllClear(21));
// { scores: {$bitsAllClear: [0, 2, 4]} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAllClear(0, 2, 4));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/query/bitsAnyClear/&#34;&gt;$bitsAnyClear &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// We want to compare the `bitvector` field with the value 0b00010101.
// The following two queries are equivalent:

// { scores: {$bitsAnyClear: 21} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAnyClear(21));
// { scores: {$bitsAnyClear: [0, 2, 4]} }
auto results = User::find(MANGROVE_KEY(User::bitvector).bitsAnyClear(0, 2, 4));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Operators</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/4-updates/operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/4-updates/operators/</guid>
      <description>

&lt;p&gt;The following is a list of the available &lt;strong&gt;update operators&lt;/strong&gt; for the Mangrove expression builder.
This page follows the structure of the

&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/&#34;&gt;MongoDB update operator documentation &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;

&lt;h3 id=&#34;field-update-operators&#34;&gt;Field Update Operators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/inc/&#34;&gt;$inc &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$inc&lt;/code&gt; operator is provided as the C++ &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; operators.
The unary &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; can also be used.
It is only enabled for fields with a numeric type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Increment the age of users in the database.
// The following three statements are the same, and produce the BSON:
// { $inc: {age: 1}}
auto res = User::update_many({}, MANGROVE_KEY(User::age) += 1);
res = User::update_many({}, MANGROVE_KEY(User::age)++);
res = User::update_many({}, ++MANGROVE_KEY(User::age));

// Decrement the time left in the free trial of some product.
// The following three statements are the same, and produce the BSON:
// { $inc: {trial_days_left: -1}}
auto res = User::update_many({}, MANGROVE_KEY(User::trial_days_left) -= 1);
res = User::update_many({}, MANGROVE_KEY(User::trial_days_left)--);
res = User::update_many({}, --MANGROVE_KEY(User::trial_days_left));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/mul/&#34;&gt;$mul &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$mul&lt;/code&gt; operator is provided as the C++ &lt;code&gt;*=&lt;/code&gt; operator.
It is only enabled for fields with a numeric type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Double the scores of users in a game.
// { $mul: {score: 2}}
auto res = User::update_many({}, MANGROVE_KEY(User::score) *= 2);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/rename/&#34;&gt;$rename &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Mangrove does not provide the &lt;code&gt;$rename&lt;/code&gt; operator, since changing the name of fields created during serialization is not possible.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/setOnInsert/&#34;&gt;$setOnInsert &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on the fields.
The given value must be the same type as the field (or implicitly cast to it).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Reset the score of a user, or create a new one.
// Note the use of the &amp;quot;upsert&amp;quot; option, to enable insertion of a new document if necessary.
// { $set: {score: 0}, $setOnInsert: {hours_played: 0} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 (MANGROVE_KEY(User::score) = 0,
                                  MANGROVE_KEY(User::hours_played).set_on_insert(0)),
                                 mongocxx::options::update{}.upsert(true));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/set/&#34;&gt;$set &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$set&lt;/code&gt; operator is provided as the C++ assignment operator &lt;code&gt;=&lt;/code&gt;.
The given value must be the same type as the field (or implicitly cast to it).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Edit the username of a user
// { $set: {username: &amp;quot;brohemian_raphsody&amp;quot;}}
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                MANGROVE_KEY(User::username) = &amp;quot;brohemian_raphsody&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/unset/&#34;&gt;$unset &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on fields that takes no arguments.
The field it is used on must be an &lt;code&gt;optional&lt;/code&gt; field.
Otherwise, an error is raised at compile time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Remove the &amp;quot;current_school&amp;quot; field from a user who has graduated:
// {$unset: {current_school: &amp;quot;&amp;quot;}}
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::current_school).unset());
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/min/&#34;&gt;$min &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on fields.
The given value must be the same type as the field (or implicitly cast to it).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Update a user&#39;s lowest score in a game.
// {$min: {lowest_score: 45}}
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::lowest_score).min(45));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/max/&#34;&gt;$max &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on fields.
The given value must be the same type as the field (or implicitly cast to it).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Update a user&#39;s high score in a game.
// {$max: {lowest_score: 1000}}
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::high_score).max(1000));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/currentDate/&#34;&gt;$currentDate &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To set a field to the current date using the &lt;code&gt;$currentDate&lt;/code&gt; operator, one can use assign the reserved value &lt;code&gt;mangrove::current_date&lt;/code&gt; to a field using &lt;code&gt;=&lt;/code&gt;. This is only enabled for date or timestamp fields.
The &lt;code&gt;$type&lt;/code&gt; argument to the &lt;code&gt;$currentDate&lt;/code&gt; operator is determined by the type of the field itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Update a user&#39;s &amp;quot;last played&amp;quot; date.
// { $currentDate: {last_played: {$type: &amp;quot;date&amp;quot;}} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::last_played) = mangrove::current_date);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;array-update-operators&#34;&gt;Array Update Operators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/positional/&#34;&gt;$ &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$&lt;/code&gt; operator is used to update the first element in an array that matches the given query.
This is done in Mangrove by using the &lt;code&gt;.first_match()&lt;/code&gt; member function on name-value-pairs.
The result is then used in an update expression as if it were a regular name-value pair.&lt;/p&gt;

&lt;p&gt;This operator is only enabled for fields that are arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Double a players&#39; first score over 1000.
// { $mul: {&amp;quot;scores.$&amp;quot;: 2}}
auto res = User::update_many(MANGROVE_KEY(User::scores).elem_match(MANGROVE_ELEM(User::scores) &amp;gt; 1000),
                                  MANGROVE_KEY(User::scores).first_match() *= 2);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/addToSet/&#34;&gt;$addToSet &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is available as a member function on the fields objects.
It is only enabled for fields that are arrays.
There are two versions: one that takes a single value to be added to the array,
and another that takes an iterable containing multiple values to be added.
The second one is equivalent to using the &lt;code&gt;$each&lt;/code&gt; modifier with &lt;code&gt;$addToSet&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Add a movie to a user&#39;s set of purchased movies.
// { $addToSet: {purchased_movies: &amp;quot;The Matrix&amp;quot;} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                  MANGROVE_KEY(User::purchased_movies).add_to_set(&amp;quot;The Matrix&amp;quot;));
// Add several movies at once:
// { $addToSet: {purchased_movies:
//                  {$each: [&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;]}
//              } }
auto movies = std::vector&amp;lt;std::string&amp;gt;{&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;};
res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                             MANGROVE_KEY(User::purchased_movies).add_to_set(movies));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/pop/&#34;&gt;$pop &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on the name-value-pairs.
It accepts a single parameter, a boolean &lt;code&gt;last&lt;/code&gt; that determines whether an element should be removed
from the end (if &lt;code&gt;last == true&lt;/code&gt;) of the list, or the start (if &lt;code&gt;last == false&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Remove the earliest score of some user.
// { $pop: {scores: -1} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                            MANGROVE_KEY(User::scores).pop(false));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/pull/&#34;&gt;$pull &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on the name-value-pairs.
There are two options: one which takes a value to be removed from the list,
and another which takes a query and removes values that match the given query.&lt;/p&gt;

&lt;p&gt;In the second one, the syntax for queries is similar to that of the &lt;code&gt;$elemMatch&lt;/code&gt; operators.
One can use find queries as they would at the top level (i.e. when passing to &lt;code&gt;find(...)&lt;/code&gt;),
except that scalar arrays need to use the &lt;code&gt;MANGROVE_ELEM&lt;/code&gt; macro to refer to elements.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$pull&lt;/code&gt; is only enabled for fields that are arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Remove the first matrix movie from a user&#39;s purchased movies.
// { $pull: {purchased_movies: &amp;quot;The Matrix&amp;quot;} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                  MANGROVE_KEY(User::purchased_movies).pull(&amp;quot;The Matrix&amp;quot;));

// Remove any and all matrix movies from a user&#39;s purchased movies.
// { $pull: {purchased_movies: {$regex: &amp;quot;matrix&amp;quot;, $options: &amp;quot;i&amp;quot;}} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::purchased_movies).pull(MANGROVE_ELEM(User::purchased_movies)).regex(&amp;quot;matrix&amp;quot;, &amp;quot;i&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/pullAll/&#34;&gt;$pullAll &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This operator is provided as a member function on the fields.
It accepts an iterable argument, that contains a list of values to remove from the field&amp;rsquo;s array.
This operator is only enabled for fields that are arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Remove the three matrix movies from a user&#39;s purchased movies.
// { $pullAll: {purchased_movies: [&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;]} }
auto movies = std::vector&amp;lt;std::string&amp;gt;{&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;};
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::purchased_movies).pullAll(movies));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/pushAll/&#34;&gt;$pushAll &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;$pushAll&lt;/code&gt; is deprecated, one should use &lt;code&gt;$push&lt;/code&gt; instead.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/push/&#34;&gt;$push &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$push&lt;/code&gt; operator is provided as a member function on the fields.
There are two versions: one which takes a single value to push onto the array,
and another which takes an iterable, and pushes all the values onto the array
using the &lt;code&gt;$each&lt;/code&gt; modifier.&lt;/p&gt;

&lt;p&gt;This operator is only enabled for fields that are arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Push a single movie to a user&#39;s watched_movies field:
// {$push: {watched_movies: &amp;quot;The Matrix&amp;quot;}}
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::watched_movies).push(&amp;quot;The Matrix&amp;quot;));

// This user watched every Matrix movie in one sitting:
// {$push: {watched_movies: {$each: [&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;]}}}
auto movies = std::vector&amp;lt;std::string&amp;gt;{&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;};
res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                            MANGROVE_KEY(User::watched_movies).push(movies));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As per the MongoDB documentation, &lt;code&gt;$push&lt;/code&gt; can accept several optional modifiers.
Modifiers to this operator can either be specified
as &lt;code&gt;optional&lt;/code&gt; arguments to the function, or using a &amp;ldquo;fluent&amp;rdquo; API.
This means that parameters are given as &lt;code&gt;.push(values).slice(...).sort(...).position(...)&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/slice/&#34;&gt;$slice &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;
&amp;mdash; this modifier takes a 32-bit integer that limits the number of array elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Add movies to this user&#39;s history, but limit its length to 10.
// {
//  $push: {
//      watched_movies: {$each: [&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;],
//                       $slice: 10}
//      }
// }
auto movies = std::vector&amp;lt;std::string&amp;gt;{&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;};
res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                            MANGROVE_KEY(User::watched_movies).push(movies).slice(10));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/sort/&#34;&gt;$sort &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;
&amp;mdash; this modifier takes either an integer that is &amp;plusmn;1, or a &lt;em&gt;sort expression&lt;/em&gt;.
An integer argument will sort values by their natural ordering, either in ascending (&lt;code&gt;+1&lt;/code&gt;)
or descending (&lt;code&gt;-1&lt;/code&gt;) order.
A &lt;em&gt;sort expression&lt;/em&gt; represents an ordering based on a specific field.
It can be specified by calling the &lt;code&gt;.sort(bool ascending)&lt;/code&gt; function on a name-value pair.
The boolean argument &lt;code&gt;ascending&lt;/code&gt; orders elements in ascending order if &lt;code&gt;true&lt;/code&gt;,
or descending if &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Add movies to this user&#39;s history, then sort movies in ascending order by their title.
// {
//  $push: {
//      watched_movies: {$each: [&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;],
//                       $sort: 1}
//      }
// }
auto movies = std::vector&amp;lt;std::string&amp;gt;{&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;};
res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                            MANGROVE_KEY(User::watched_movies).push(movies).sort(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If, in the above example, movies were not strings but documents, with a &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;rating&lt;/code&gt;
field, one would be able to choose how to sort them as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Add movies to this user&#39;s history, then sort movies by rating in descending order.
// {
//  $push: {
//      watched_movies: {$each: [ {title: &amp;quot;The Matrix&amp;quot;, rating: 9},
//                                {title: &amp;quot;The Matrix: Reloaded&amp;quot;, rating: 7},
//                                {title: &amp;quot;The Matrix: Revolutions&amp;quot;, rating: 3} ],
//                       $sort: {rating: -1}}
//      }
// }

// brace-initialize &amp;quot;Movie&amp;quot; objects.
auto movies = std::vector&amp;lt;Movie&amp;gt;{{&amp;quot;The Matrix&amp;quot;, 9}, {&amp;quot;The Matrix: Reloaded&amp;quot;, 7},
                                       {&amp;quot;The Matrix: Revolutions&amp;quot;, 3}};
res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                            MANGROVE_KEY(User::watched_movies).push(movies).sort(MANGROVE_KEY(Movie::rating).sort(false)));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/position/&#34;&gt;$position &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;
&amp;mdash; this modifier takes an unsigned integer that represents a position in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Add movies to this user&#39;s history, but add them at the start (i.e. 0th position)
// of the array.
// {
//  $push: {
//      watched_movies: {$each: [&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;],
//                       $position: 0}
//      }
// }
auto movies = std::vector&amp;lt;std::string&amp;gt;{&amp;quot;The Matrix&amp;quot;, &amp;quot;The Matrix: Reloaded&amp;quot;, &amp;quot;The Matrix: Revolutions&amp;quot;};
res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                            MANGROVE_KEY(User::watched_movies).push(movies).position(0));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bitwise-operators&#34;&gt;Bitwise Operators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/bit/&#34;&gt;$bit &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Bitwise updates on fields can be performed using C++&amp;rsquo;s built-in &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, and &lt;code&gt;^=&lt;/code&gt; operators.
These are only enabled for integer fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Perform bitwise operations on a user&#39;s age, because, hey, why not?!
// { $bit: {age: {and: 7}} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                 MANGROVE_KEY(User::age) &amp;amp;= 7);

// { $bit: {age: {or: 7}} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                  MANGROVE_KEY(User::age) |= 7);

// { $bit: {age: {xor: 7}} }
auto res = User::update_one(MANGROVE_KEY(User::username) == &amp;quot;raphofkhan&amp;quot;,
                                   MANGROVE_KEY(User::age) ^= 7);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;isolation-operators&#34;&gt;Isolation Operators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/operator/update/isolated/&#34;&gt;$isolated &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An update expression can be marked as isolated using the &lt;code&gt;$isolated&lt;/code&gt; operator.
In Mangrove, is this done by passing the query expression used to match documents to the &lt;code&gt;mangrove::isolated&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Set the &#39;can_buy_alcohol&#39; flag for all users over the age of 21, but isolate the updates
// to avoid concurrency issues. This is equivalent to the mongo shell command:
// db.testcollection.updateMany({age: {$gt: 21}, $isolated: 1},
//                          {$set: {can_buy_alcohol: true}})
auto res = User::update_many(mangrove::isolated(MANGROVE_KEY(User::age) &amp;gt;= 21),
                                 MANGROVE_KEY(User::can_buy_alcohol) = true);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>What is Mangrove?</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/1-basics/what-is-mangrove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/1-basics/what-is-mangrove/</guid>
      <description>&lt;p&gt;Mangrove is a C++ &lt;strong&gt;object document mapper (ODM)&lt;/strong&gt; for MongoDB. An &lt;strong&gt;ODM&lt;/strong&gt; lets you map classes in an object-oriented programming language to collections in a document-oriented database like MongoDB.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve ever used an &lt;strong&gt;object relational mapper (ORM)&lt;/strong&gt;, an &lt;strong&gt;ODM&lt;/strong&gt; is quite similar, except that the underlying structure of the data in the database is actually very similar to the structure of your objects.&lt;/p&gt;

&lt;p&gt;If you know how to create and manipulate classes in C++, you can easily get started with Mangrove!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class BlogEntry : public mangrove::model&amp;lt;BlogEntry&amp;gt; {
   public:
    std::string title;
    std::string contents;
    std::string author;
    std::chrono::system_clock::time_point time_posted;

    // Register fields with Mangrove.
    MANGROVE_MAKE_KEYS_MODEL(BlogEntry, 
                             MANGROVE_NVP(title),
                             MANGROVE_NVP(contents),
                             MANGROVE_NVP(author),
                             MANGROVE_NVP(time_posted))
};

int main() {
    mongocxx::instance{};
    mongocxx::client conn{mongocxx::uri{}};

    // Map the BlogEntry class to the &#39;entries&#39; collection
    // in the &#39;my_blog&#39; database.
    auto db = conn[&amp;quot;my_blog&amp;quot;];
    BlogEntry::setCollection(db[&amp;quot;entries&amp;quot;]);

    // Create a new entry just like any other C++ object.
    BlogEntry new_entry{&amp;quot;Check out Mangrove&amp;quot;,
                        &amp;quot;It&#39;s really cool!&amp;quot;,
                        &amp;quot;Ben Franklin&amp;quot;,
                        std::chrono::system_clock::now()}


    // Save the entry in the collection.
    new_entry.save();

    // There is now a document in the &#39;entries&#39; collection
    // and it looks like this:
    // {
    //    &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;577d5b36e24939f3b82e2331&amp;quot;),
    //    &amp;quot;title&amp;quot; : &amp;quot;Check out Mangrove!&amp;quot;,
    //    &amp;quot;contents&amp;quot; : &amp;quot;It&#39;s really cool&amp;quot;,
    //    &amp;quot;author&amp;quot; : &amp;quot;Ben Franklin&amp;quot;,
    //    &amp;quot;time_posted&amp;quot; : ISODate(&amp;quot;2016-07-15T19:25:42.073Z&amp;quot;)
    // }
}


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Allowed Types</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/2-models/allowed-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/2-models/allowed-types/</guid>
      <description>

&lt;p&gt;As we discussed in the previous section, there are a limited number of types that you can save and load, or &lt;strong&gt;serialize&lt;/strong&gt; in the database within your models. Here we&amp;rsquo;ll enumerate every type that you can include in the &lt;code&gt;MANGROVE_MAKE_KEYS_MODEL&lt;/code&gt; macro.&lt;/p&gt;

&lt;h2 id=&#34;primitive-types&#34;&gt;Primitive Types&lt;/h2&gt;

&lt;p&gt;Mangrove officially supports the following four primitive types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int32_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int64_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Mangrove will also accept other primitive types such as &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, or &lt;code&gt;unsigned int&lt;/code&gt;, but we highly recommend that you go with one of the four supported types. Other types will be implicitly cast to one of the four supported types, which might cause unpredictable behavior that differs from platform to platform.&lt;/p&gt;
&lt;/div&gt;


&lt;h2 id=&#34;strings&#34;&gt;Strings&lt;/h2&gt;

&lt;p&gt;Mangrove supports the serialization of &lt;code&gt;std::string&lt;/code&gt;. If you prefer to use string &amp;ldquo;views&amp;rdquo; that minimize the number of copies your program makes, check out the &lt;code&gt;bsoncxx::types::b_utf8&lt;/code&gt; type discussed in &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/2-models/allowed-types/#bson-view-types&#34;&gt;BSON &amp;ldquo;View&amp;rdquo; Types&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;time-points&#34;&gt;Time Points&lt;/h2&gt;

&lt;p&gt;Mangrove supports &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt;. This type is preferred for representing a point in time. If your program uses the C-style &lt;code&gt;std::time_t&lt;/code&gt; type, we recommend that you use the &lt;code&gt;to_time_t()&lt;/code&gt; and &lt;code&gt;from_time_t()&lt;/code&gt; functions discussed in 
&lt;a target=&#34;_blank&#34; href=&#34;http://en.cppreference.com/w/cpp/chrono/system_clock&#34;&gt;the documentation for &lt;code&gt;std::chrono::system_clock&lt;/code&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 so that your class can support &lt;code&gt;time_point&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;

&lt;p&gt;Mangrove supports a number of C++ STL Containers as serializable. The following containers will work as long as the type they contain is one of the allowed types discussed on this page.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::vector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::unordered_set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::forward_list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::deque&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::valarray&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all serialized in the database as BSON arrays.&lt;/p&gt;

&lt;h2 id=&#34;embedded-documents&#34;&gt;Embedded Documents&lt;/h2&gt;

&lt;p&gt;MongoDB documents often contain embedded documents, which most likely don&amp;rsquo;t logically map to a common C++ type. Fortunately, Mangrove allows you to create classes that represent subdocuments that may be present in a normal document.&lt;/p&gt;

&lt;p&gt;Creating a serializable subclass is straightfoward, and very similar to creating a model. Simply take your class, and instead of inheriting from &lt;code&gt;mangrove::model&lt;/code&gt; and calling &lt;code&gt;MANGROVE_MAKE_KEYS_MODEL&lt;/code&gt;, just call &lt;code&gt;MANGROVE_MAKE_KEYS&lt;/code&gt; on the types you want serialized in the subdocument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class ContactCard {
    std::string description;
    std::string address;
    std::string phone;

    MANGROVE_MAKE_KEYS(ContactCard,
                       MANGROVE_NVP(description),
                       MANGROVE_NVP(address),
                       MANGROVE_NVP(phone))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the above class definition, you can now have a model like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Employee : public mmangrove::model&amp;lt;Employee&amp;gt; {
    std::string name;
    double hourly_wage;
    ContactCard contact_info;

    MANGROVE_MAKE_KEYS_MODEL(Employee,
                             MANGROVE_NVP(name),
                             MANGROVE_NVP(hourly_wage),
                             MANGROVE_NVP(contact_info))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can even include subdocuments in an STL container like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Employee : public mmangrove::model&amp;lt;Employee&amp;gt; {
    std::string name;
    double hourly_wage;
    std::vector&amp;lt;ContactCard&amp;gt; contact_info;

    MANGROVE_MAKE_KEYS_MODEL(Employee,
                             MANGROVE_NVP(name),
                             MANGROVE_NVP(hourly_wage),
                             MANGROVE_NVP(contact_info))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the resulting document would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;578fcf796119b016e0a3b079&amp;quot;),
    &amp;quot;name&amp;quot; : &amp;quot;Jenny&amp;quot;,
    &amp;quot;hourly_wage&amp;quot; : 19.81,
    &amp;quot;contact_info&amp;quot; : [
        {
            &amp;quot;type&amp;quot; : &amp;quot;home&amp;quot;,
            &amp;quot;phone&amp;quot; : &amp;quot;212-867-5309&amp;quot;,
            &amp;quot;address&amp;quot; : &amp;quot;247 E 26 St, New York, NY&amp;quot;
        },
        {
            &amp;quot;type&amp;quot; : &amp;quot;work&amp;quot;,
            &amp;quot;phone&amp;quot; : &amp;quot;555-123-4567&amp;quot;,
            &amp;quot;address&amp;quot; : &amp;quot;570 Second Ave, New York, NY&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only restriction regarding serializable subdocuments is that they must be &lt;em&gt;default constructible&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;optionals&#34;&gt;Optionals&lt;/h2&gt;

&lt;p&gt;Although 
&lt;a target=&#34;_blank&#34; href=&#34;http://en.cppreference.com/w/cpp/utility/optional/optional&#34;&gt;&lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 won&amp;rsquo;t be available until C++17, Mangrove offers it as a serializable type in the form of &lt;code&gt;bson_mapper::stdx::optional&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;optional&lt;/code&gt; is a powerful new C++ type that specifies a value that may or may not exist.&lt;/p&gt;

&lt;p&gt;Mangrove offers support for optional types where &lt;code&gt;T&lt;/code&gt; is a type discussed on this page. This gives Mangrove support for dynamic, flexible schemas, which will be discussed in a &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/2-models/dynamic-schemas&#34;&gt;later section&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;objectids&#34;&gt;ObjectIDs&lt;/h2&gt;

&lt;p&gt;One of the fundamental types in MongoDB is the 
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/bson-types/#objectid&#34;&gt;ObjectID &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
. ObjectIDs are the default type used for the &lt;code&gt;_id&lt;/code&gt; field in documents, so you may want to use them in your project.&lt;/p&gt;

&lt;p&gt;The MongoDB C++ Driver offers the 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-driver/classbsoncxx_1_1oid.html&#34;&gt;&lt;code&gt;bsoncxx::oid&lt;/code&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
, which is a simple class that can be used to create and compare ObjectIDs. Mangrove offers serialization support for &lt;code&gt;bsoncxx::oid&lt;/code&gt; so you can include them in your models as well.&lt;/p&gt;

&lt;h2 id=&#34;bson-types&#34;&gt;BSON Types&lt;/h2&gt;

&lt;p&gt;The MongoDB C++ Driver offers a library called &lt;code&gt;libbsoncxx&lt;/code&gt; that contains a set of utilities for using and manipulating BSON in C++. One of these utilities is a set of C++ types that cover every supported type in the 
&lt;a target=&#34;_blank&#34; href=&#34;http://bsonspec.org/spec.html&#34;&gt;BSON Specification &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;While the following types are all technically supported, we do not recommend using them if you can accomplish the same result with one of types discussed in the other sections. Many of the following types are dangerous and only used internally by MongoDB.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;These types, which are all defined in 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-driver/types_8hpp_source.html&#34;&gt;&lt;code&gt;bsoncxx/types.hpp&lt;/code&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
, are all supported as serializable by Mangrove.&lt;/p&gt;

&lt;p&gt;The following types, which are in the &lt;code&gt;bsoncxx::types::&lt;/code&gt; namespace are supported without any further configuration:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b_double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_date&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_int32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_int64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_timestamp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_minkey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_maxkey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_oid&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Not to be confused with the &lt;code&gt;bsoncxx::oid&lt;/code&gt; discussed in the previous section.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bson-view-types&#34;&gt;BSON &amp;ldquo;View&amp;rdquo; Types&lt;/h3&gt;

&lt;p&gt;Some of the types defined in the &lt;code&gt;bsoncxx::types::&lt;/code&gt; namespace are non-owning &amp;ldquo;views&amp;rdquo; to their underlying data, meaning that they can be dangerous if the address they pointing to is freed from memory. The following types are BSON &amp;ldquo;views&amp;rdquo;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b_utf8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_document&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_array&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_binary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_regex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_dbpointer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_code&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_codewscope&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b_symbol&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mangrove only supports these types if, in the class containing them, you inherit from &lt;code&gt;bson_mapper::UnderlyingBSONDataBase&lt;/code&gt;. When data is loaded from the database and deserialized into this class, 
&lt;a target=&#34;_blank&#34; href=&#34;http://mongodb.github.io/mongo-cxx-odm/api/html/classbson__mapper_1_1UnderlyingBSONDataBase.html&#34;&gt;&lt;code&gt;UnderlyingBSONDataBase&lt;/code&gt; &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 holds a &lt;code&gt;std::shared_ptr&lt;/code&gt; to the original BSON data from which it was deserialized. This ensures that any BSON view types in the class will never point to deallocated memory after being read from the database.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installation</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/1-basics/installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/1-basics/installation/</guid>
      <description>

&lt;p&gt;To get Mangrove up and running in your project, simply follow these instructions to install Mangrove on your system.&lt;/p&gt;

&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Any little-endian platform.&lt;/li&gt;
&lt;li&gt;A modern compiler that supports C++14.

&lt;ul&gt;
&lt;li&gt;Mangrove has been confirmed to work with Clang 3.8+, Apple Clang 7.3+, or GCC 6.1+.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CMake 3.2+.&lt;/li&gt;
&lt;li&gt;The MongoDB C driver version 1.3.5+. (see below)&lt;/li&gt;
&lt;li&gt;The MongoDB C++ driver version 3.0.2+. (see below)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;(Optional)&lt;/em&gt; pkg-config&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;build-and-install-the-c-driver&#34;&gt;Build and install the C driver&lt;/h2&gt;

&lt;p&gt;Mangrove uses 
&lt;a target=&#34;_blank&#34; href=&#34;https://api.mongodb.com/libbson/current/&#34;&gt;libbson &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 and 
&lt;a target=&#34;_blank&#34; href=&#34;https://api.mongodb.com/c/current/&#34;&gt;libmongoc &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 internally. If you don&amp;rsquo;t already have a new enough version of libmongoc and libbson installed, then you need to build them.&lt;/p&gt;

&lt;p&gt;Build and install libmongoc according to the section 
&lt;a target=&#34;_blank&#34; href=&#34;https://api.mongodb.com/c/current/installing.html#unix-build&#34;&gt;Building From a Release Tarball &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 in the install instructions. libmongoc installs libbson if necessary.&lt;/p&gt;

&lt;h2 id=&#34;build-and-install-the-c-11-driver&#34;&gt;Build and install the C++11 driver&lt;/h2&gt;

&lt;p&gt;Mangrove also uses the 
&lt;a target=&#34;_blank&#34; href=&#34;https://github.com/mongodb/mongo-cxx-driver&#34;&gt;MongoDB C++11 Driver &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 internally.&lt;/p&gt;

&lt;p&gt;Build and install the C++ driver according to its 
&lt;a target=&#34;_blank&#34; href=&#34;https://github.com/mongodb/mongo-cxx-driver/wiki/Quickstart-Guide-%28New-Driver%29&#34;&gt;quickstart guide &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;

&lt;h2 id=&#34;build-and-install-mangrove&#34;&gt;Build and install Mangrove&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Clone the repository, and check out the latest stable release.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone -b master https://github.com/mongodb/mongo-cxx-odm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Build Mangrove. Note that if you installed the C driver and C++ driver to a path that is automatically searched by &lt;code&gt;pkg-config&lt;/code&gt;, you can omit the &lt;code&gt;PKG_CONFIG_PATH&lt;/code&gt; environment variable. If you don&amp;rsquo;t have &lt;code&gt;pkg-config&lt;/code&gt;, you can explicitly set the path to the libbson, libmongoc, libbsoncxx, and libmongocxx install prefixes with the &lt;code&gt;-DLIBBSON_DIR&lt;/code&gt;, &lt;code&gt;-DLIBMONGOC_DIR&lt;/code&gt;, -&lt;code&gt;Dlibbsoncxx_DIR&lt;/code&gt;, and &lt;code&gt;-Dlibmongocxx_DIR&lt;/code&gt; CMake arguments.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cd mongo-cxx-odm/build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[PKG_CONFIG_PATH=CXXDRIVER_INSTALL_PATH/lib/pkgconfig] cmake -DCMAKE_BUILD_TYPE=Release [-DCMAKE_INSTALL_PREFIX=DESIRED_INSTALL_PATH] ..&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Custom _id Type</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/2-models/custom_id/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/2-models/custom_id/</guid>
      <description>

&lt;p&gt;As we mentioned in the chapter&amp;rsquo;s &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/2-models/introduction&#34;&gt;Introduction&lt;/a&gt;, Mangrove &lt;strong&gt;models&lt;/strong&gt; automatically include an &lt;code&gt;_id&lt;/code&gt; field that is automatically an ObjectID of type &lt;code&gt;bsoncxx::oid&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are various reasons that you might not want to use an ObjectId for the &lt;code&gt;_id&lt;/code&gt; field. Therefore, Mangrove supports the customization of the &lt;code&gt;_id&lt;/code&gt; type via a second template parameter to &lt;code&gt;mangrove::model&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Below is an exampe of a model that uses std::string as an &lt;code&gt;_id&lt;/code&gt; instead of an ObjectID:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class User : public mangrove::model&amp;lt;User, std::string&amp;gt; {
	std::string username;
	std::string password_hash;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting BSON document may look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;_id&amp;quot; : &amp;quot;alan.turing@mongodb.com&amp;quot;,
	&amp;quot;username&amp;quot; : &amp;quot;aturing&amp;quot;,
	&amp;quot;password_hash&amp;quot; :
		 &amp;quot;e9f5bd2bae1c70770ff8c6e6cf2d7b76&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;supported-types&#34;&gt;Supported Types&lt;/h2&gt;

&lt;p&gt;Mangrove supports any type discussed in &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/2-models/allowed-types&#34;&gt;Allowed Types&lt;/a&gt; as &lt;code&gt;_id&lt;/code&gt;&amp;rsquo;s type, except for container types, &lt;code&gt;b_regex&lt;/code&gt;, and &lt;code&gt;b_array&lt;/code&gt;. This means that you can even use an embedded document as your &lt;code&gt;_id&lt;/code&gt; type!&lt;/p&gt;

&lt;p&gt;You can read 
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/core/document/#document-id-field&#34;&gt;this article &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 in the MongoDB Manual to learn more about the exact limitations of the &lt;code&gt;_id&lt;/code&gt; field.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick Tour</title>
      <link>http://mongodb.github.io/mongo-cxx-odm/1-basics/quick-tour/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://mongodb.github.io/mongo-cxx-odm/1-basics/quick-tour/</guid>
      <description>

&lt;p&gt;Now that you have Mangrove installed on your system, we can get started with a quick tour of Mangrove&amp;rsquo;s features. To do this, we&amp;rsquo;ll develop the data model for a very simple persistent blog application.&lt;/p&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;This guide assumes a basic working knowledge of both C++ and MongoDB. You can find a basic introduction to the concepts of MongoDB in
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/introduction/&#34;&gt;MongoDB&amp;rsquo;s manual &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;
&lt;/div&gt;


&lt;h2 id=&#34;creating-a-blog-entry-model&#34;&gt;Creating a Blog Entry Model&lt;/h2&gt;

&lt;p&gt;First, we&amp;rsquo;ll want to set up a class to represent a blog entry. A blog entry will have a title, an author, some content, and a posting time. We can represent this in C++ with something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;chrono&amp;gt;

class BlogEntry {
public:
    std::string title;
    std::string author;
    std::string content;
    std::chrono::system_clock::time_point time_posted;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to store blog entries in the database, we&amp;rsquo;ll have to make the &lt;code&gt;BlogEntry&lt;/code&gt; class a Mangrove &lt;strong&gt;model&lt;/strong&gt;. Making a class a &lt;strong&gt;model&lt;/strong&gt; gives the class the semantics of a MongoDB &lt;strong&gt;collection&lt;/strong&gt;, as well as instance &lt;code&gt;save()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; functions for 
&lt;a target=&#34;_blank&#34; href=&#34;https://en.wikipedia.org/wiki/Active_record_pattern&#34;&gt;active record &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 style access to the database.&lt;/p&gt;

&lt;p&gt;To make &lt;code&gt;BlogEntry&lt;/code&gt; a &lt;strong&gt;model&lt;/strong&gt;, simply have it inherit from &lt;code&gt;mangrove::model&amp;lt;BlogEntry&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;chrono&amp;gt;

#include &amp;lt;mangrove/model.hpp&amp;gt;

class BlogEntry : public mangrove::model&amp;lt;BlogEntry&amp;gt; {
public:
    std::string title;
    std::string author;
    std::string content;
    std::chrono::system_clock::time_point time_posted;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the model class is templated on the class that you want to make a model. This is an example of a 
&lt;a target=&#34;_blank&#34; href=&#34;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&#34;&gt;curiously recurring template parameter &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
, a C++ pattern that lets the parent class have access to the type inheriting from it.&lt;/p&gt;

&lt;p&gt;Before we can use the model, we must also specify which fields we want to be included when a &lt;code&gt;BlogEntry&lt;/code&gt; is saved in the database. We can do this with the &lt;code&gt;MANGROVE_MAKE_KEYS_MODEL&lt;/code&gt; macro:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;chrono&amp;gt;

#include &amp;lt;mangrove/nvp.hpp&amp;gt;

class BlogEntry : public mangrove::model&amp;lt;BlogEntry&amp;gt; {
public:
    std::string title;
    std::string contents;
    std::string author;
    std::chrono::system_clock::time_point time_posted;

    MANGROVE_MAKE_KEYS_MODEL(BlogEntry, 
                             MANGROVE_NVP(title),
                             MANGROVE_NVP(contents),
                             MANGROVE_NVP(author),
                             MANGROVE_NVP(time_posted))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This macro specifies that blog entries should be stored in the database with the title, author, content, and time posted, and where the name of those fields should be the name of the variables. Manually specifying which class members are included when saving to the database lets you have class members that you might not necessarily want to store persistently in the database.&lt;/p&gt;

&lt;h2 id=&#34;registering-the-model-with-a-mongodb-collection&#34;&gt;Registering the Model with a MongoDB Collection&lt;/h2&gt;

&lt;p&gt;The last step you must take before you can use the &lt;code&gt;BlogEntry&lt;/code&gt; model is to register the model with a MongoDB database using the MongoDB C++ Driver. In the following example, we&amp;rsquo;ll use a connection to the database hosted at &lt;code&gt;localhost&lt;/code&gt; on port 27017.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;mongocxx/client.hpp&amp;gt;
#include &amp;lt;mongocxx/instance.hpp&amp;gt;

int main() {
    mongocxx::instance{};
    mongocxx::client 
        conn{mongocxx::uri{&amp;quot;mongodb://localhost:27017&amp;quot;};

    BlogEntry::setCollection(conn[&amp;quot;my_blog&amp;quot;][&amp;quot;entries&amp;quot;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;BlogEntry&lt;/code&gt; model has a static function &lt;code&gt;setCollection()&lt;/code&gt; that lets you specify in which collection to save and retrieve instances of &lt;code&gt;BlogEntry&lt;/code&gt;. It accepts a &lt;code&gt;mongocxx::collection&lt;/code&gt;, which is accessible via the &lt;code&gt;mongocxx::client&lt;/code&gt;. The code above sets &lt;code&gt;BlogEntry&lt;/code&gt;&amp;rsquo;s collection to the &lt;code&gt;&amp;quot;entries&amp;quot;&lt;/code&gt; collection in the &lt;code&gt;&amp;quot;my_blog&amp;quot;&lt;/code&gt; database hosted at &lt;code&gt;&amp;quot;mongodb://localhost:27017&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re planning on writing multi-threaded applications with Mangrove, be sure to carefully read the warning &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/2-models/introduction/#linking-with-the-database&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;saving-objects&#34;&gt;Saving Objects&lt;/h2&gt;

&lt;p&gt;Now that you&amp;rsquo;ve set up the model and registered it with a collection, you can start interacting with the database. The simplest way to do this is to create instances of the object and call the save() method. The following very simple function will save a blog entry to the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void newEntry(std::string title, std::string author, std::string content) { 
    BlogEntry entry{title, author, content,
                    std::chrono::system_clock::now()};
    entry.save();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This particular function doesn&amp;rsquo;t do anything with the object after saving it to the database, but you are able to modify the &lt;code&gt;entry&lt;/code&gt; object and call save() again to modify the object and save the changes in the database.&lt;/p&gt;

&lt;h2 id=&#34;querying-objects&#34;&gt;Querying Objects&lt;/h2&gt;

&lt;p&gt;Querying objects in Mangrove is just as easy as saving them. When you make &lt;code&gt;BlogEntry&lt;/code&gt; a &lt;strong&gt;model&lt;/strong&gt;, you gave it the static methods &lt;code&gt;find()&lt;/code&gt; and &lt;code&gt;findOne()&lt;/code&gt;, which have very similar semantics to 
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/method/db.collection.find/&#34;&gt;their &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/manual/reference/method/db.collection.findOne/&#34;&gt;equivalents &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 in the mongo shell.&lt;/p&gt;

&lt;p&gt;The following function prints out the titles of every blog entry by a particular author using a &lt;code&gt;find()&lt;/code&gt; query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

#include &amp;lt;mangrove/query_builder.hpp&amp;gt;

void printTitlesBy(std::string author) {
    std::cout &amp;lt;&amp;lt; &amp;quot;All blog entries by &amp;quot; &amp;lt;&amp;lt; author &amp;lt;&amp;lt; &amp;quot;:\n&amp;quot;;
    for (auto entry : BlogEntry::find(MANGROVE_KEY(BlogEntry::author) == author)) {
        std::cout &amp;lt;&amp;lt; entry.title &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a lot happening here, but it&amp;rsquo;s very simple once you understand what&amp;rsquo;s going on.&lt;/p&gt;

&lt;p&gt;Inside the parameter list for &lt;code&gt;BlogEntry::find()&lt;/code&gt;, you&amp;rsquo;ll see &lt;code&gt;MANGROVE_KEY(BlogEntry::author) == author&lt;/code&gt;. In Mangrove, you can build MongoDB queries using the standard C++ comparison and logical operators. This is discussed more in &lt;a href=&#34;http://mongodb.github.io/mongo-cxx-odm/3-queries&#34;&gt;Chapter 3&lt;/a&gt;, but the main thing you have to remember is to wrap the value you are comparing in a &lt;code&gt;MANGROVE_KEY&lt;/code&gt; macro.&lt;/p&gt;

&lt;p&gt;The return type of &lt;code&gt;BlogEntry::find()&lt;/code&gt; is an iterator of &lt;code&gt;BlogEntry&lt;/code&gt;s. This makes it very easy to work with the often large cursors of objects that are returned from MongoDB queries. In this case, we are interacting with the cursor via the C++11 
&lt;a target=&#34;_blank&#34; href=&#34;http://en.cppreference.com/w/cpp/language/range-for&#34;&gt;range-based for loop &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
.&lt;/p&gt;

&lt;div class=&#34;notices info&#34; &gt;&lt;p&gt;The iterator returned by the model&amp;rsquo;s &lt;code&gt;find()&lt;/code&gt; method has the semantics of a MongoDB &lt;strong&gt;cursor&lt;/strong&gt;. This is useful for large queries where you want to periodically read from the database as you&amp;rsquo;re reading from the query results, but this also gives the cursors some interesting behavior such as inactive cursor closure and the lack of cursor isolation. If you want to learn more about these behaviors, check out
&lt;a target=&#34;_blank&#34; href=&#34;https://docs.mongodb.com/v3.2/tutorial/iterate-a-cursor/#cursor-behaviors&#34;&gt;this page &lt;i class=&#34;fa fa-external-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;
 in the MongoDB manual.&lt;/p&gt;
&lt;/div&gt;


&lt;h2 id=&#34;bulk-updates&#34;&gt;Bulk Updates&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>